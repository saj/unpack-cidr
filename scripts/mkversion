#!/bin/bash

# Create an ephemeral version module.
#
# This project sources its release version strings from the names of Git tags.
# This script plumbs Git metadata into a Python module that will later be read
# by setuptools to define the 'public version identifier' (see PEP-440) of the
# project's Python distribution.
#
# No version module will be written unless a Git tag points to the current HEAD.

set -u


get_version() {
  git describe --tags --exact-match --dirty --match 'v*' 2>/dev/null \
    | awk -F '-' -v OFS='-' '\
        BEGIN { \
          found=0 \
        }; \
        { \
          sub(/^v/, "", $1); \
          if ($NF != "dirty") { \
            print $0; \
            found=1 \
          } \
        }; \
        END { \
          if (!found) { \
            exit 1 \
          } \
        }'
}


create_version_file() {
  local -r path="$1"
  local -r version="$2"
  local -r me="${BASH_SOURCE[0]##*/}"

  cat - >"${path}" <<EOF
"""This file automatically generated by ${me}."""

VERSION = "${version}"
EOF
  chmod u+rw "${path}"
}


remove_version_file() {
  local -r path="$1"

  rm -f "${path}"
  if [[ "${path}" =~ \.py$ ]]; then
    # Remove cached .pyc and potential friends.
    rm -f "${path}"?
  fi
}


prefix_relative_path_with_pwd() {
  local -r path="$1"

  if [[ -z "${path}" ]]; then
    return 1
  fi
  if [[ "${path:0:1}" = '/' ]]; then
    echo "${path}"
    return 0
  fi
  echo "${PWD}/${path}"
}


main() {
  local -r version_path="$(prefix_relative_path_with_pwd ${1:-''})"

  if [[ -z "${version_path}" ]]; then
    echo 'required argument not supplied: path' >&2
    return 1
  fi

  if [[ -e "${version_path}" && ! -w "${version_path}" ]]; then
    return 0
  fi

  remove_version_file "${version_path}"

  local -r version="$(get_version)"
  if [[ -n "${version}" ]]; then
    create_version_file "${version_path}" "${version}"
  fi
}


main "$@"
